# Client-Server Communication Flow in MCP Rust SDK

This document describes the flow of communication between a client and server in the MCP Rust SDK, referencing the concrete objects and methods involved.

---

## 1. Connection Establishment

### **Server Side**
- The server listens for incoming TCP connections using [`tokio::net::TcpListener`] in [`Server::run`].
- For each new connection, a [`ServerSession`] is created via [`ServerSession::from_socket`].

### **Client Side**
- The client connects to the server using [`tokio::net::TcpStream`] in [`ClientSessionGroup::connect_to_server`].

---

## 2. Splitting the TCP Stream

Both client and server split the TCP stream into read and write halves:
- `let (read_half, write_half) = tokio::io::split(stream);`
- These are wrapped in [`BufReader`] and [`BufWriter`] for buffered async I/O.

---

## 3. Channel Setup

### **Server**
- Two channels are set up in [`ServerSession::from_socket`]:
  - `read_tx`/`read_rx`: For messages read from the socket and passed to the server logic.
  - `write_tx`/`write_rx`: For messages generated by the server logic to be sent to the client.

### **Client**
- Similarly, the client sets up `read_tx`/`read_rx` and `write_tx`/`write_rx` for its own message handling.

---

## 4. Task Spawning

### **Server**
- **Read Task:**  
  Reads from the socket, parses messages using [`ProtocolMessage::read_from_stream`], and sends them to `read_tx`.
- **Write Task:**  
  Listens on `write_rx` and writes messages to the socket using [`ProtocolMessage::write_to_stream`].

### **Client**
- The client has analogous read/write tasks for its own side of the connection.

---

## 5. Server Message Handling

### **Method: `ServerSession::handle_messages`**
- Consumes messages from `read_rx`.
- Handles each [`ProtocolMessage`] variant:
  - `ProtocolMessage::Initialize`: Responds with handshake info.
  - `ProtocolMessage::Data`: Dispatches based on the `method` field (`handle_initialize`, `handle_list_resources`, `handle_list_tools`, `handle_call_tool`, or `handle_unknown_method`).
  - `ProtocolMessage::Error`: Logs and forwards error to the client using `handle_unknown_method`.

#### **Sending a Response**
- Handlers like `handle_initialize` and `handle_unknown_method` send responses to the client by calling `self.write_stream.send(...)`, which is picked up by the server's write task and written to the socket.

---

## 6. Client Message Handling

### **Method: `ClientSession::handle_messages`**
- Consumes messages from its own `read_rx`.
- Handles protocol messages (e.g., handshake, data, error) and acts accordingly.

---

## 7. Error Handling

- If the server's read task encounters a protocol error, it sends a `ProtocolMessage::Error` to `read_tx`.
- `ServerSession::handle_messages` receives this, and (after your fix) forwards it to the client via `handle_unknown_method`, which sends it to `write_tx`, and thus over the socket.

---

## 8. Serialization

- All messages sent over the socket are serialized as JSON lines, using [`serde_json`] and the [`ProtocolMessage`] enum.

---

## Sequence Diagram (Summary)

```text
Client                 ServerSession
  |                         |
  |--- TCP Connect -------->|
  |                         |
  |--- ProtocolMessage ----->| (read task parses, sends to read_tx)
  |                         |
  |                  handle_messages (from read_rx)
  |                         |
  |<-- ProtocolMessage ------| (write_stream.send, write task writes to socket)
  |                         |
```

---

## Key Objects and Methods

| Object/Struct         | Purpose                                      | Key Methods/Fields                           |
|-----------------------|----------------------------------------------|----------------------------------------------|
| `Server`              | Main server type                             | `run`                                        |
| `ServerSession`       | Per-connection session                       | `from_socket`, `handle_messages`, channels   |
| `ProtocolMessage`     | Enum for all protocol messages               | `read_from_stream`, `write_to_stream`        |
| `ClientSessionGroup`  | Manages client sessions                      | `connect_to_server`                          |
| `ClientSession`       | Per-connection client session                | `handle_messages`                            |

---

## Communication Pathways

- **Socket → Read Task → `read_tx` → `ServerSession::handle_messages`**
- **`ServerSession::handle_messages` → `write_stream.send` → `write_rx` → Write Task → Socket**

---

## How User Code Integrates with the SDK Flow

This section explains how you, as a user of the MCP Rust SDK, connect your own application logic to the communication flow described above.

### 1. Server Side Integration

**Example: Registering Handlers and Running the Server**

```rust
use mcp::server::Server;

#[tokio::main]
async fn main() {
    let mut server = Server::new();

    // Register handler for resource listing
    server.list_resources(|params| {
        // Your custom logic here
        vec![]
    });

    // Register handler for tool listing
    server.list_tools(|params| {
        Box::pin(async { Ok(ListToolsResult { tools: vec![] }) })
    });

    // Start the server
    server.run("127.0.0.1:12345").await.unwrap();
}
```

- When a client sends a message (e.g., `"method": "resources/list"`), the SDK routes it to your registered handler.
- Your handler's return value is sent back to the client via the protocol flow.

### 2. Client Side Integration

**Example: Connecting and Sending Requests**

```rust
use mcp::client::ClientSessionGroup;

#[tokio::main]
async fn main() {
    let mut group = ClientSessionGroup::new();
    let url = "tcp://127.0.0.1:12345".parse().unwrap();

    group.connect_to_server(url).await.unwrap();

    // Send a request to list resources
    let resources = group.list_resources(&url).await.unwrap();
    println!("Resources: {:?}", resources.resources);
}
```

- The SDK manages the network connection, message serialization, and response handling.
- You interact with the protocol by calling high-level methods on the client session group.

### 3. Message Flow to User Code

**Server:**
1. Message arrives from client →
2. Parsed in read task →
3. Sent to `ServerSession::handle_messages` →
4. Routed to your handler (e.g., `list_resources_handler`) →
5. Your code runs and returns a response →
6. SDK serializes and sends response to client.

**Client:**
1. You call a method (e.g., `list_resources`) →
2. SDK sends request over socket →
3. Waits for and parses response →
4. Returns result to your code.

### 4. Integration Diagram

```text
User Code (Server)      MCP SDK           Network         MCP SDK           User Code (Client)
------------------      -------           -------         -------           ------------------
list_resources_handler   <---+                |               +--->    group.list_resources()
(your closure)              |                |               |              (your call)
                            |                |               |
                            |  <---->  TCP   |   <---->      |
                            |                |               |
```

---

For more details, see the source code for each struct and method referenced above.
